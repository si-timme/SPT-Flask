from datetime import datetime
from typing import Sequence


def _header(tag: str) -> str:
    ts = datetime.utcnow().strftime("%Y-%m-%d %H:%M UTC")
    return f"% Auto-generated by Signal Processing toolkit \u2014 {tag} \u2014 {ts}\n"


def matlab_script(
    name: str,
    b: Sequence[float],
    a: Sequence[float],
    *,
    order: int,
    filter_type: str,
    cutoff: str,
    sample_rate: float,
) -> str:

    ts = datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S UTC")
    header = f"% Auto-generated by Signal Processing toolkit — MATLAB — {ts}"

    b_txt = " ".join(f"{coef:.18g}" for coef in b)
    a_txt = " ".join(f"{coef:.18g}" for coef in a)

    lines: List[str] = [
        header,
        "% ----------------------------------------------------------------",
        "% FILTER SPECS",
        f"%   Type  : {filter_type}",
        f"%   Order : {order}",
        f"%   Cutoff: {cutoff}  (Hz)",
        f"%   Fs    : {sample_rate}  (samples/sec)",
        "%",
        "% USAGE (paste in MATLAB console)",
        "%   1) Quick smoke-test       >> myFilter_*YOUR_NAME*",
        "%   2) Filter a signal        >> [y,b,a] = myFilter_*YOUR_NAME*(x)",
        "%   3) Inspect coeffs only    >> [~,b,a] = myFilter_*YOUR_NAME*",
        "%   4) Impulse response       >> [~,b,a] = myFilter_*YOUR_NAME*; impz(b,a)",
        "% ----------------------------------------------------------------",
        "",
        f"function [y, b, a] = {name}(x)",
        "    % Coefficient vectors",
        f"    b = [{b_txt}];",
        f"    a = [{a_txt}];",
        "",
        "    % ------------------------------------------------------------",
        "    %  DEMO MODE  —  if no data supplied",
        "    % ------------------------------------------------------------",
        "    if nargin == 0 || isempty(x)",
        "        x  = randn(1e4, 1);      % white-noise test vector",
        "        y  = filter(b, a, x);",
        "        fvtool(b, a);           % magnitude / phase",
        "        return",
        "    end",
        "",
        "    % ------------------------------------------------------------",
        "    %  NORMAL FILTERING PATH",
        "    % ------------------------------------------------------------",
        "    y = filter(b, a, x);",
        "end",
        "",
    ]

    return "\n".join(lines)


def python_script(name: str, b: Sequence[float], a: Sequence[float]) -> str:
    lines = [_header("Python"), "import numpy as np", "from scipy.signal import lfilter", ""]
    b_vals = ", ".join(f"{coef:.12g}" for coef in b)
    a_vals = ", ".join(f"{coef:.12g}" for coef in a)
    lines.append(f"b = np.array([{b_vals}], dtype=float)")
    lines.append(f"a = np.array([{a_vals}], dtype=float)")
    lines.append("")
    lines.append(f"def {name}(x):")
    lines.append("    return lfilter(b, a, x)")
    lines.append("")
    return "\n".join(lines)


def arduino_ino(name: str, b: Sequence[float], a: Sequence[float]) -> str:
    lines = ["/*" + _header("Arduino").strip() + "*/"]
    nb = len(b)
    na = len(a) - 1
    lines.append(f"const int NB = {nb};")
    lines.append(f"const int NA = {na};")
    b_vals = ", ".join(f"{coef:.7g}f" for coef in b)
    neg_a = [-coef for coef in a[1:]]
    a_vals = ", ".join(f"{coef:.7g}f" for coef in neg_a)
    lines.append(f"float b[NB] = {{{b_vals}}};")
    lines.append(f"float a[NA] = {{{a_vals}}};")
    lines.append("const int N = (NB > NA ? NB : NA);")
    lines.append("float w[N] = {0};")
    lines.append("")
    lines.append(f"float {name}(float x) {{")
    lines.append("    float acc = x;")
    lines.append("    for (int i = 0; i < NA; ++i) acc -= a[i] * w[i];")
    lines.append("    for (int i = N - 1; i > 0; --i) w[i] = w[i-1];")
    lines.append("    w[0] = acc;")
    lines.append("    float y = 0;")
    lines.append("    for (int i = 0; i < NB; ++i) y += b[i] * w[i];")
    lines.append("    return y;")
    lines.append("}")
    lines.append("")
    return "\n".join(lines)